use super::*;
use ceramic_core::{Bytes,RangeOpen};
use lalrpop_util::ParseError;

grammar;

pub Record : Record = {
    <cat:Cat> <dog:Dog> <iterations:Iteration*> => Record {
        cat,
        dog,
        iterations,
    },
};
Cat: ReconMemoryBytes<FixedInterests> = {
    "cat:" <interests:Interests?> <set:Set> => ReconMemoryBytes::new(BTreeStore::from_set(set), interests.unwrap_or_else(|| FixedInterests::full())),
};
Dog: ReconMemoryBytes<FixedInterests> = {
    "dog:" <interests:Interests?> <set:Set> => ReconMemoryBytes::new(BTreeStore::from_set(set), interests.unwrap_or_else(|| FixedInterests::full())),
};

Interests: FixedInterests = {
    "<" <first:Interest?> <rest:("," <Interest>)*> ">" => {
        let mut interests = Vec::new();
        if let Some(first) = first {
            interests.push(first);
        }
        interests.extend(rest.into_iter());
        FixedInterests(interests)
    }
};

Interest: RangeOpen<Bytes> = {
    "(" <start:Word> "," <end:Word> ")" => (Bytes::from(start), Bytes::from(end)).into()
};

Set: Set = {
    "[" <SetInner> "]" => <>
};

SetInner: Set = {
    <first:Word?> <rest:("," <Word>)*> => {
        let mut set = Set::new();
        set.extend(rest.iter().map(Bytes::from));
        if let Some(first) = first {
            set.insert(Bytes::from(first));
        }
        set
    }
};

Word : String = {
    r"[a-z][a-z0-9]*"=> <>.to_string(),
};

Iteration : Iteration = {
    <dir:Direction> <messages:Messages> <set:Set> => Iteration {
        dir,
        messages,
        set,
    }
};


Direction : Direction = {
    "->" => Direction::CatToDog,
    "<-" => Direction::DogToCat,
};

Messages : Vec<MessageData> = {
    <first:Message?> <rest:("," <Message>)*> => {
        let mut messages = Vec::new();
        if let Some(first) = first {
            messages.push(first);
        }
        messages.extend(rest.into_iter());
        messages
    }
}
Message : MessageData = {
    "(" <MessageItem?> <("," <MessageItem>)*> ")" =>? (<>).try_into().map_err(|e: &'static str| ParseError::User{
        error: e,
    })
};

MessageItem : MessageItem = {
    "h(" <SetInner> ")" => MessageItem::Hash(<>),
    "0"                 => MessageItem::Hash(Set::new()),
    "<" <Word>          => MessageItem::Start(<>),
    <Word> ">"          => MessageItem::End(<>),
    Word                => MessageItem::Key(<>),
};
